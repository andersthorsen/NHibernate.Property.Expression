# NHibernate.Property.Expression
A convention based expression resolver for NHibernate. If a &lt;PropertyName>Expression exists it will be used for Linq queries.

On your data object do this:
```csharp
 public class Person
    {
        public virtual Guid Id { get; set; }
        public virtual string Name { get; set; }
        public virtual DateTime StartDate { get; set; }
        public virtual DateTime? EndDate { get; set; }
        public virtual Person Manager { get; set; }

        public static Expression<Func<Person, bool>> IsActiveExpression =
            person => person.StartDate <= DateTimeTestable.Today() && (person.EndDate == null || person.EndDate >= DateTimeTestable.Today());

        public static Func<Person, bool> CompiledIsActive = IsActiveExpression.Compile(); 

        public virtual bool IsActive { get { return CompiledIsActive(this); } }
    }
```
    
    The important parts are the IsActiveExpression field and the IsActive property as they are linked by convention.
    
    To query, use 
```csharp
    session.QueryExtended<Person>().Where(p => p.IsActive)
```

  When a new NHibernate is releaset it appears it appears that it will be possible to do (in github code for NHibernate):
  cfg.SetProperty(Environment.QueryLinqProvider, typeof(ExpressionUnpackQueryProvider).Name)
  
  and use the normal
```csharp
  session.Query<Person>().Where(p => p.IsActive)
```
    
    The sql generated by NHibernate will be something like this:
    
```sql
    select
        person0_.Id as Id0_,
        person0_.Name as Name0_,
        person0_.StartDate as StartDate0_,
        person0_.EndDate as EndDate0_,
        person0_.Manager as Manager0_ 
    from
        Person person0_ 
    where
        person0_.StartDate<=@p0 
        and (
            person0_.EndDate is null 
            or person0_.EndDate>=@p1
        );
```
